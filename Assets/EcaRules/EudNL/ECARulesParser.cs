//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.7.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from ECARulesParser.g4 by ANTLR 4.7.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

namespace EcaRules
{


	[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.7.1")]
	[System.CLSCompliant(false)]
	public partial class ECARulesParser : Parser
	{
		protected static DFA[] decisionToDFA;
		protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
		public const int
			WHITESPACE = 1, WHEN = 2, THEN = 3, IF = 4, THE = 5, X = 6, Y = 7, Z = 8, AXIS = 9, DEFINE = 10,
			CONDITION = 11, HAS = 12, GT = 13, LT = 14, NOT = 15, EQUAL = 16, LE = 17, GE = 18, NOTEQUAL = 19,
			AND = 20, OR = 21, ADD = 22, SUB = 23, MUL = 24, DIV = 25, MOD = 26, IS = 27, LPAREN = 28,
			RPAREN = 29, LBRACE = 30, RBRACE = 31, LBRACK = 32, RBRACK = 33, SEMI = 34, COMMA = 35,
			DOT = 36, COLOR = 37, POSITION = 38, PATH = 39, A = 40, AS = 41, AT = 42, AROUND = 43,
			BY = 44, FOR = 45, FROM = 46, IN = 47, ON = 48, OF = 49, OFF = 50, TO = 51, WITH = 52, DEGREES = 53,
			POV_LITERAL = 54, BOOL_LITERAL = 55, BOOL_YES_NO = 56, COLOR_LITERAL = 57, DECIMAL_LITERAL = 58,
			IDENTIFIER = 59, STRING_LITERAL = 60, FLOAT_LITERAL = 61, TIME_LITERAL = 62, MEASURE_UNIT = 63;
		public const int
			RULE_program = 0, RULE_declaration = 1, RULE_objectDeclaration = 2, RULE_positionDeclaration = 3,
			RULE_positionLiteral = 4, RULE_pathDeclaration = 5, RULE_colorDeclaration = 6,
			RULE_floatLiteral = 7, RULE_type = 8, RULE_position = 9, RULE_path = 10,
			RULE_angle = 11, RULE_color = 12, RULE_behaviourDeclaration = 13, RULE_alias = 14,
			RULE_ecarule = 15, RULE_action = 16, RULE_subject = 17, RULE_verb = 18,
			RULE_object = 19, RULE_value = 20, RULE_modifier = 21, RULE_preposition = 22,
			RULE_property = 23, RULE_condition = 24, RULE_baseCondition = 25, RULE_operator = 26;
		public static readonly string[] ruleNames = {
		"program", "declaration", "objectDeclaration", "positionDeclaration",
		"positionLiteral", "pathDeclaration", "colorDeclaration", "floatLiteral",
		"type", "position", "path", "angle", "color", "behaviourDeclaration",
		"alias", "ecarule", "action", "subject", "verb", "object", "value", "modifier",
		"preposition", "property", "condition", "baseCondition", "operator"
	};

		private static readonly string[] _LiteralNames = {
		null, null, "'when'", "'then'", "'if'", "'the'", "'x'", "'y'", "'z'",
		"'axis'", "'define'", "'condition'", "'has'", "'>'", "'<'", "'not'", "'='",
		"'<='", "'>='", "'!='", "'and'", "'or'", "'+'", "'-'", "'*'", "'/'", "'%'",
		"'is'", "'('", "')'", "'{'", "'}'", "'['", "']'", "';'", "','", "'.'",
		"'color'", "'position'", "'path'", "'a'", "'as'", "'at'", "'around'",
		"'by'", "'for'", "'from'", "'in'", "'on'", "'of'", "'off'", "'to'", "'with'",
		"'degrees'"
	};
		private static readonly string[] _SymbolicNames = {
		null, "WHITESPACE", "WHEN", "THEN", "IF", "THE", "X", "Y", "Z", "AXIS",
		"DEFINE", "CONDITION", "HAS", "GT", "LT", "NOT", "EQUAL", "LE", "GE",
		"NOTEQUAL", "AND", "OR", "ADD", "SUB", "MUL", "DIV", "MOD", "IS", "LPAREN",
		"RPAREN", "LBRACE", "RBRACE", "LBRACK", "RBRACK", "SEMI", "COMMA", "DOT",
		"COLOR", "POSITION", "PATH", "A", "AS", "AT", "AROUND", "BY", "FOR", "FROM",
		"IN", "ON", "OF", "OFF", "TO", "WITH", "DEGREES", "POV_LITERAL", "BOOL_LITERAL",
		"BOOL_YES_NO", "COLOR_LITERAL", "DECIMAL_LITERAL", "IDENTIFIER", "STRING_LITERAL",
		"FLOAT_LITERAL", "TIME_LITERAL", "MEASURE_UNIT"
	};
		public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

		[NotNull]
		public override IVocabulary Vocabulary
		{
			get
			{
				return DefaultVocabulary;
			}
		}

		public override string GrammarFileName { get { return "ECARulesParser.g4"; } }

		public override string[] RuleNames { get { return ruleNames; } }

		public override string SerializedAtn { get { return new string(_serializedATN); } }

		static ECARulesParser()
		{
			decisionToDFA = new DFA[_ATN.NumberOfDecisions];
			for (int i = 0; i < _ATN.NumberOfDecisions; i++)
			{
				decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
			}
		}

		public ECARulesParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public ECARulesParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
		{
			Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
		}
		public partial class ProgramContext : ParserRuleContext
		{
			public DeclarationContext[] declaration()
			{
				return GetRuleContexts<DeclarationContext>();
			}
			public DeclarationContext declaration(int i)
			{
				return GetRuleContext<DeclarationContext>(i);
			}
			public BehaviourDeclarationContext[] behaviourDeclaration()
			{
				return GetRuleContexts<BehaviourDeclarationContext>();
			}
			public BehaviourDeclarationContext behaviourDeclaration(int i)
			{
				return GetRuleContext<BehaviourDeclarationContext>(i);
			}
			public EcaruleContext[] ecarule()
			{
				return GetRuleContexts<EcaruleContext>();
			}
			public EcaruleContext ecarule(int i)
			{
				return GetRuleContext<EcaruleContext>(i);
			}
			public AliasContext[] alias()
			{
				return GetRuleContexts<AliasContext>();
			}
			public AliasContext alias(int i)
			{
				return GetRuleContext<AliasContext>(i);
			}
			public ProgramContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_program; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterProgram(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitProgram(this);
			}
		}

		[RuleVersion(0)]
		public ProgramContext program()
		{
			ProgramContext _localctx = new ProgramContext(Context, State);
			EnterRule(_localctx, 0, RULE_program);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 55;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do
					{
						{
							{
								State = 54; declaration();
							}
						}
						State = 57;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while (_la == DEFINE);
					State = 62;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la == THE)
					{
						{
							{
								State = 59; behaviourDeclaration();
							}
						}
						State = 64;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					State = 66;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					do
					{
						{
							{
								State = 65; ecarule();
							}
						}
						State = 68;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					} while (_la == WHEN);
					State = 73;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la == DEFINE)
					{
						{
							{
								State = 70; alias();
							}
						}
						State = 75;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class DeclarationContext : ParserRuleContext
		{
			public ObjectDeclarationContext objectDeclaration()
			{
				return GetRuleContext<ObjectDeclarationContext>(0);
			}
			public PositionDeclarationContext positionDeclaration()
			{
				return GetRuleContext<PositionDeclarationContext>(0);
			}
			public PathDeclarationContext pathDeclaration()
			{
				return GetRuleContext<PathDeclarationContext>(0);
			}
			public ColorDeclarationContext colorDeclaration()
			{
				return GetRuleContext<ColorDeclarationContext>(0);
			}
			public DeclarationContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_declaration; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterDeclaration(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitDeclaration(this);
			}
		}

		[RuleVersion(0)]
		public DeclarationContext declaration()
		{
			DeclarationContext _localctx = new DeclarationContext(Context, State);
			EnterRule(_localctx, 2, RULE_declaration);
			try
			{
				State = 80;
				ErrorHandler.Sync(this);
				switch (Interpreter.AdaptivePredict(TokenStream, 4, Context))
				{
					case 1:
						EnterOuterAlt(_localctx, 1);
						{
							State = 76; objectDeclaration();
						}
						break;
					case 2:
						EnterOuterAlt(_localctx, 2);
						{
							State = 77; positionDeclaration();
						}
						break;
					case 3:
						EnterOuterAlt(_localctx, 3);
						{
							State = 78; pathDeclaration();
						}
						break;
					case 4:
						EnterOuterAlt(_localctx, 4);
						{
							State = 79; colorDeclaration();
						}
						break;
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class ObjectDeclarationContext : ParserRuleContext
		{
			public ITerminalNode DEFINE() { return GetToken(ECARulesParser.DEFINE, 0); }
			public TypeContext type()
			{
				return GetRuleContext<TypeContext>(0);
			}
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public ITerminalNode SEMI() { return GetToken(ECARulesParser.SEMI, 0); }
			public ObjectDeclarationContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_objectDeclaration; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterObjectDeclaration(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitObjectDeclaration(this);
			}
		}

		[RuleVersion(0)]
		public ObjectDeclarationContext objectDeclaration()
		{
			ObjectDeclarationContext _localctx = new ObjectDeclarationContext(Context, State);
			EnterRule(_localctx, 4, RULE_objectDeclaration);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 82; Match(DEFINE);
					State = 83; type();
					State = 84; Match(IDENTIFIER);
					State = 85; Match(SEMI);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class PositionDeclarationContext : ParserRuleContext
		{
			public ITerminalNode DEFINE() { return GetToken(ECARulesParser.DEFINE, 0); }
			public ITerminalNode POSITION() { return GetToken(ECARulesParser.POSITION, 0); }
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public ITerminalNode EQUAL() { return GetToken(ECARulesParser.EQUAL, 0); }
			public PositionLiteralContext positionLiteral()
			{
				return GetRuleContext<PositionLiteralContext>(0);
			}
			public ITerminalNode SEMI() { return GetToken(ECARulesParser.SEMI, 0); }
			public PositionDeclarationContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_positionDeclaration; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterPositionDeclaration(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitPositionDeclaration(this);
			}
		}

		[RuleVersion(0)]
		public PositionDeclarationContext positionDeclaration()
		{
			PositionDeclarationContext _localctx = new PositionDeclarationContext(Context, State);
			EnterRule(_localctx, 6, RULE_positionDeclaration);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 87; Match(DEFINE);
					State = 88; Match(POSITION);
					State = 89; Match(IDENTIFIER);
					State = 90; Match(EQUAL);
					State = 91; positionLiteral();
					State = 92; Match(SEMI);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class PositionLiteralContext : ParserRuleContext
		{
			public ITerminalNode LPAREN() { return GetToken(ECARulesParser.LPAREN, 0); }
			public FloatLiteralContext[] floatLiteral()
			{
				return GetRuleContexts<FloatLiteralContext>();
			}
			public FloatLiteralContext floatLiteral(int i)
			{
				return GetRuleContext<FloatLiteralContext>(i);
			}
			public ITerminalNode[] COMMA() { return GetTokens(ECARulesParser.COMMA); }
			public ITerminalNode COMMA(int i)
			{
				return GetToken(ECARulesParser.COMMA, i);
			}
			public ITerminalNode RPAREN() { return GetToken(ECARulesParser.RPAREN, 0); }
			public PositionLiteralContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_positionLiteral; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterPositionLiteral(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitPositionLiteral(this);
			}
		}

		[RuleVersion(0)]
		public PositionLiteralContext positionLiteral()
		{
			PositionLiteralContext _localctx = new PositionLiteralContext(Context, State);
			EnterRule(_localctx, 8, RULE_positionLiteral);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 94; Match(LPAREN);
					State = 95; floatLiteral();
					State = 96; Match(COMMA);
					State = 97; floatLiteral();
					State = 98; Match(COMMA);
					State = 99; floatLiteral();
					State = 100; Match(RPAREN);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class PathDeclarationContext : ParserRuleContext
		{
			public ITerminalNode DEFINE() { return GetToken(ECARulesParser.DEFINE, 0); }
			public ITerminalNode PATH() { return GetToken(ECARulesParser.PATH, 0); }
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public ITerminalNode EQUAL() { return GetToken(ECARulesParser.EQUAL, 0); }
			public ITerminalNode LBRACE() { return GetToken(ECARulesParser.LBRACE, 0); }
			public PositionLiteralContext[] positionLiteral()
			{
				return GetRuleContexts<PositionLiteralContext>();
			}
			public PositionLiteralContext positionLiteral(int i)
			{
				return GetRuleContext<PositionLiteralContext>(i);
			}
			public ITerminalNode RBRACE() { return GetToken(ECARulesParser.RBRACE, 0); }
			public ITerminalNode SEMI() { return GetToken(ECARulesParser.SEMI, 0); }
			public ITerminalNode COMMA() { return GetToken(ECARulesParser.COMMA, 0); }
			public PathDeclarationContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_pathDeclaration; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterPathDeclaration(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitPathDeclaration(this);
			}
		}

		[RuleVersion(0)]
		public PathDeclarationContext pathDeclaration()
		{
			PathDeclarationContext _localctx = new PathDeclarationContext(Context, State);
			EnterRule(_localctx, 10, RULE_pathDeclaration);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 102; Match(DEFINE);
					State = 103; Match(PATH);
					State = 104; Match(IDENTIFIER);
					State = 105; Match(EQUAL);
					State = 106; Match(LBRACE);
					State = 107; positionLiteral();
					State = 110;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la == COMMA)
					{
						{
							State = 108; Match(COMMA);
							State = 109; positionLiteral();
						}
					}

					State = 112; Match(RBRACE);
					State = 113; Match(SEMI);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class ColorDeclarationContext : ParserRuleContext
		{
			public ITerminalNode DEFINE() { return GetToken(ECARulesParser.DEFINE, 0); }
			public ITerminalNode COLOR() { return GetToken(ECARulesParser.COLOR, 0); }
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public ITerminalNode EQUAL() { return GetToken(ECARulesParser.EQUAL, 0); }
			public ITerminalNode COLOR_LITERAL() { return GetToken(ECARulesParser.COLOR_LITERAL, 0); }
			public ITerminalNode SEMI() { return GetToken(ECARulesParser.SEMI, 0); }
			public ColorDeclarationContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_colorDeclaration; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterColorDeclaration(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitColorDeclaration(this);
			}
		}

		[RuleVersion(0)]
		public ColorDeclarationContext colorDeclaration()
		{
			ColorDeclarationContext _localctx = new ColorDeclarationContext(Context, State);
			EnterRule(_localctx, 12, RULE_colorDeclaration);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 115; Match(DEFINE);
					State = 116; Match(COLOR);
					State = 117; Match(IDENTIFIER);
					State = 118; Match(EQUAL);
					State = 119; Match(COLOR_LITERAL);
					State = 120; Match(SEMI);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class FloatLiteralContext : ParserRuleContext
		{
			public ITerminalNode FLOAT_LITERAL() { return GetToken(ECARulesParser.FLOAT_LITERAL, 0); }
			public ITerminalNode DECIMAL_LITERAL() { return GetToken(ECARulesParser.DECIMAL_LITERAL, 0); }
			public FloatLiteralContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_floatLiteral; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterFloatLiteral(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitFloatLiteral(this);
			}
		}

		[RuleVersion(0)]
		public FloatLiteralContext floatLiteral()
		{
			FloatLiteralContext _localctx = new FloatLiteralContext(Context, State);
			EnterRule(_localctx, 14, RULE_floatLiteral);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 122;
					_la = TokenStream.LA(1);
					if (!(_la == DECIMAL_LITERAL || _la == FLOAT_LITERAL))
					{
						ErrorHandler.RecoverInline(this);
					}
					else
					{
						ErrorHandler.ReportMatch(this);
						Consume();
					}
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class TypeContext : ParserRuleContext
		{
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public TypeContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_type; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterType(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitType(this);
			}
		}

		[RuleVersion(0)]
		public TypeContext type()
		{
			TypeContext _localctx = new TypeContext(Context, State);
			EnterRule(_localctx, 16, RULE_type);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 124; Match(IDENTIFIER);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class PositionContext : ParserRuleContext
		{
			public ITerminalNode THE() { return GetToken(ECARulesParser.THE, 0); }
			public ITerminalNode POSITION() { return GetToken(ECARulesParser.POSITION, 0); }
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public PositionContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_position; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterPosition(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitPosition(this);
			}
		}

		[RuleVersion(0)]
		public PositionContext position()
		{
			PositionContext _localctx = new PositionContext(Context, State);
			EnterRule(_localctx, 18, RULE_position);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 126; Match(THE);
					State = 127; Match(POSITION);
					State = 128; Match(IDENTIFIER);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class PathContext : ParserRuleContext
		{
			public ITerminalNode THE() { return GetToken(ECARulesParser.THE, 0); }
			public ITerminalNode PATH() { return GetToken(ECARulesParser.PATH, 0); }
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public PathContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_path; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterPath(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitPath(this);
			}
		}

		[RuleVersion(0)]
		public PathContext path()
		{
			PathContext _localctx = new PathContext(Context, State);
			EnterRule(_localctx, 20, RULE_path);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 130; Match(THE);
					State = 131; Match(PATH);
					State = 132; Match(IDENTIFIER);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class AngleContext : ParserRuleContext
		{
			public FloatLiteralContext floatLiteral()
			{
				return GetRuleContext<FloatLiteralContext>(0);
			}
			public ITerminalNode DEGREES() { return GetToken(ECARulesParser.DEGREES, 0); }
			public ITerminalNode AROUND() { return GetToken(ECARulesParser.AROUND, 0); }
			public ITerminalNode AXIS() { return GetToken(ECARulesParser.AXIS, 0); }
			public ITerminalNode X() { return GetToken(ECARulesParser.X, 0); }
			public ITerminalNode Y() { return GetToken(ECARulesParser.Y, 0); }
			public ITerminalNode Z() { return GetToken(ECARulesParser.Z, 0); }
			public AngleContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_angle; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterAngle(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitAngle(this);
			}
		}

		[RuleVersion(0)]
		public AngleContext angle()
		{
			AngleContext _localctx = new AngleContext(Context, State);
			EnterRule(_localctx, 22, RULE_angle);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 134; floatLiteral();
					State = 135; Match(DEGREES);
					State = 139;
					ErrorHandler.Sync(this);
					switch (Interpreter.AdaptivePredict(TokenStream, 6, Context))
					{
						case 1:
							{
								State = 136; Match(AROUND);
								State = 137;
								_la = TokenStream.LA(1);
								if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << X) | (1L << Y) | (1L << Z))) != 0)))
								{
									ErrorHandler.RecoverInline(this);
								}
								else
								{
									ErrorHandler.ReportMatch(this);
									Consume();
								}
								State = 138; Match(AXIS);
							}
							break;
					}
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class ColorContext : ParserRuleContext
		{
			public ITerminalNode THE() { return GetToken(ECARulesParser.THE, 0); }
			public ITerminalNode COLOR() { return GetToken(ECARulesParser.COLOR, 0); }
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public ColorContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_color; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterColor(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitColor(this);
			}
		}

		[RuleVersion(0)]
		public ColorContext color()
		{
			ColorContext _localctx = new ColorContext(Context, State);
			EnterRule(_localctx, 24, RULE_color);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 141; Match(THE);
					State = 142; Match(COLOR);
					State = 143; Match(IDENTIFIER);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class BehaviourDeclarationContext : ParserRuleContext
		{
			public ITerminalNode THE() { return GetToken(ECARulesParser.THE, 0); }
			public TypeContext[] type()
			{
				return GetRuleContexts<TypeContext>();
			}
			public TypeContext type(int i)
			{
				return GetRuleContext<TypeContext>(i);
			}
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public ITerminalNode HAS() { return GetToken(ECARulesParser.HAS, 0); }
			public ITerminalNode A() { return GetToken(ECARulesParser.A, 0); }
			public ITerminalNode SEMI() { return GetToken(ECARulesParser.SEMI, 0); }
			public BehaviourDeclarationContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_behaviourDeclaration; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterBehaviourDeclaration(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitBehaviourDeclaration(this);
			}
		}

		[RuleVersion(0)]
		public BehaviourDeclarationContext behaviourDeclaration()
		{
			BehaviourDeclarationContext _localctx = new BehaviourDeclarationContext(Context, State);
			EnterRule(_localctx, 26, RULE_behaviourDeclaration);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 145; Match(THE);
					State = 146; type();
					State = 147; Match(IDENTIFIER);
					State = 148; Match(HAS);
					State = 149; Match(A);
					State = 150; type();
					State = 151; Match(SEMI);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class AliasContext : ParserRuleContext
		{
			public ITerminalNode DEFINE() { return GetToken(ECARulesParser.DEFINE, 0); }
			public TypeContext type()
			{
				return GetRuleContext<TypeContext>(0);
			}
			public ITerminalNode AS() { return GetToken(ECARulesParser.AS, 0); }
			public ITerminalNode STRING_LITERAL() { return GetToken(ECARulesParser.STRING_LITERAL, 0); }
			public ITerminalNode FOR() { return GetToken(ECARulesParser.FOR, 0); }
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public ITerminalNode SEMI() { return GetToken(ECARulesParser.SEMI, 0); }
			public AliasContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_alias; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterAlias(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitAlias(this);
			}
		}

		[RuleVersion(0)]
		public AliasContext alias()
		{
			AliasContext _localctx = new AliasContext(Context, State);
			EnterRule(_localctx, 28, RULE_alias);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 153; Match(DEFINE);
					State = 154; type();
					State = 155; Match(AS);
					State = 156; Match(STRING_LITERAL);
					State = 157; Match(FOR);
					State = 158; Match(IDENTIFIER);
					State = 159; Match(SEMI);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class EcaruleContext : ParserRuleContext
		{
			public ITerminalNode WHEN() { return GetToken(ECARulesParser.WHEN, 0); }
			public ActionContext[] action()
			{
				return GetRuleContexts<ActionContext>();
			}
			public ActionContext action(int i)
			{
				return GetRuleContext<ActionContext>(i);
			}
			public ITerminalNode THEN() { return GetToken(ECARulesParser.THEN, 0); }
			public ITerminalNode IF() { return GetToken(ECARulesParser.IF, 0); }
			public ConditionContext condition()
			{
				return GetRuleContext<ConditionContext>(0);
			}
			public ITerminalNode[] SEMI() { return GetTokens(ECARulesParser.SEMI); }
			public ITerminalNode SEMI(int i)
			{
				return GetToken(ECARulesParser.SEMI, i);
			}
			public EcaruleContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_ecarule; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterEcarule(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitEcarule(this);
			}
		}

		[RuleVersion(0)]
		public EcaruleContext ecarule()
		{
			EcaruleContext _localctx = new EcaruleContext(Context, State);
			EnterRule(_localctx, 30, RULE_ecarule);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 161; Match(WHEN);
					State = 162; action();
					State = 165;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la == IF)
					{
						{
							State = 163; Match(IF);
							State = 164; condition(0);
						}
					}

					State = 167; Match(THEN);
					State = 173;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la == THE || _la == SEMI)
					{
						{
							{
								State = 168; action();
								State = 169; Match(SEMI);
							}
						}
						State = 175;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class ActionContext : ParserRuleContext
		{
			public SubjectContext subject()
			{
				return GetRuleContext<SubjectContext>(0);
			}
			public VerbContext verb()
			{
				return GetRuleContext<VerbContext>(0);
			}
			public ObjectContext @object()
			{
				return GetRuleContext<ObjectContext>(0);
			}
			public PrepositionContext preposition()
			{
				return GetRuleContext<PrepositionContext>(0);
			}
			public ValueContext value()
			{
				return GetRuleContext<ValueContext>(0);
			}
			public PropertyContext property()
			{
				return GetRuleContext<PropertyContext>(0);
			}
			public ModifierContext modifier()
			{
				return GetRuleContext<ModifierContext>(0);
			}
			public ITerminalNode MEASURE_UNIT() { return GetToken(ECARulesParser.MEASURE_UNIT, 0); }
			public ActionContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_action; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterAction(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitAction(this);
			}
		}

		[RuleVersion(0)]
		public ActionContext action()
		{
			ActionContext _localctx = new ActionContext(Context, State);
			EnterRule(_localctx, 32, RULE_action);
			int _la;
			try
			{
				State = 205;
				ErrorHandler.Sync(this);
				switch (Interpreter.AdaptivePredict(TokenStream, 13, Context))
				{
					case 1:
						EnterOuterAlt(_localctx, 1);
						{
							State = 176; subject();
							State = 177; verb();
						}
						break;
					case 2:
						EnterOuterAlt(_localctx, 2);
						{
							State = 179; subject();
							State = 180; verb();
							State = 182;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A) | (1L << AS) | (1L << AT) | (1L << AROUND) | (1L << BY) | (1L << FOR) | (1L << FROM) | (1L << IN) | (1L << ON) | (1L << OF) | (1L << OFF) | (1L << TO) | (1L << WITH))) != 0))
							{
								{
									State = 181; preposition();
								}
							}

							State = 184; @object();
						}
						break;
					case 3:
						EnterOuterAlt(_localctx, 3);
						{
							State = 186; subject();
							State = 187; verb();
							State = 189;
							ErrorHandler.Sync(this);
							switch (Interpreter.AdaptivePredict(TokenStream, 10, Context))
							{
								case 1:
									{
										State = 188; preposition();
									}
									break;
							}
							State = 191; value();
						}
						break;
					case 4:
						EnterOuterAlt(_localctx, 4);
						{
							State = 193; subject();
							State = 194; verb();
							State = 196;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A) | (1L << AS) | (1L << AT) | (1L << AROUND) | (1L << BY) | (1L << FOR) | (1L << FROM) | (1L << IN) | (1L << ON) | (1L << OF) | (1L << OFF) | (1L << TO) | (1L << WITH))) != 0))
							{
								{
									State = 195; preposition();
								}
							}

							State = 198; property();
							State = 199; modifier();
							State = 200; value();
							State = 202;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
							if (_la == MEASURE_UNIT)
							{
								{
									State = 201; Match(MEASURE_UNIT);
								}
							}

						}
						break;
					case 5:
						EnterOuterAlt(_localctx, 5);
						{
						}
						break;
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class SubjectContext : ParserRuleContext
		{
			public ITerminalNode THE() { return GetToken(ECARulesParser.THE, 0); }
			public TypeContext type()
			{
				return GetRuleContext<TypeContext>(0);
			}
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public SubjectContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_subject; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterSubject(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitSubject(this);
			}
		}

		[RuleVersion(0)]
		public SubjectContext subject()
		{
			SubjectContext _localctx = new SubjectContext(Context, State);
			EnterRule(_localctx, 34, RULE_subject);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 207; Match(THE);
					State = 208; type();
					State = 209; Match(IDENTIFIER);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class VerbContext : ParserRuleContext
		{
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public VerbContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_verb; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterVerb(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitVerb(this);
			}
		}

		[RuleVersion(0)]
		public VerbContext verb()
		{
			VerbContext _localctx = new VerbContext(Context, State);
			EnterRule(_localctx, 36, RULE_verb);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 211; Match(IDENTIFIER);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class ObjectContext : ParserRuleContext
		{
			public ITerminalNode THE() { return GetToken(ECARulesParser.THE, 0); }
			public TypeContext type()
			{
				return GetRuleContext<TypeContext>(0);
			}
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public ObjectContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_object; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterObject(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitObject(this);
			}
		}

		[RuleVersion(0)]
		public ObjectContext @object()
		{
			ObjectContext _localctx = new ObjectContext(Context, State);
			EnterRule(_localctx, 38, RULE_object);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 213; Match(THE);
					State = 214; type();
					State = 215; Match(IDENTIFIER);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class ValueContext : ParserRuleContext
		{
			public FloatLiteralContext floatLiteral()
			{
				return GetRuleContext<FloatLiteralContext>(0);
			}
			public PositionContext position()
			{
				return GetRuleContext<PositionContext>(0);
			}
			public PathContext path()
			{
				return GetRuleContext<PathContext>(0);
			}
			public AngleContext angle()
			{
				return GetRuleContext<AngleContext>(0);
			}
			public ColorContext color()
			{
				return GetRuleContext<ColorContext>(0);
			}
			public ITerminalNode POV_LITERAL() { return GetToken(ECARulesParser.POV_LITERAL, 0); }
			public ITerminalNode BOOL_LITERAL() { return GetToken(ECARulesParser.BOOL_LITERAL, 0); }
			public ITerminalNode BOOL_YES_NO() { return GetToken(ECARulesParser.BOOL_YES_NO, 0); }
			public ITerminalNode ON() { return GetToken(ECARulesParser.ON, 0); }
			public ITerminalNode OFF() { return GetToken(ECARulesParser.OFF, 0); }
			public ITerminalNode COLOR_LITERAL() { return GetToken(ECARulesParser.COLOR_LITERAL, 0); }
			public ITerminalNode TIME_LITERAL() { return GetToken(ECARulesParser.TIME_LITERAL, 0); }
			public ITerminalNode STRING_LITERAL() { return GetToken(ECARulesParser.STRING_LITERAL, 0); }
			public ValueContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_value; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterValue(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitValue(this);
			}
		}

		[RuleVersion(0)]
		public ValueContext value()
		{
			ValueContext _localctx = new ValueContext(Context, State);
			EnterRule(_localctx, 40, RULE_value);
			try
			{
				State = 230;
				ErrorHandler.Sync(this);
				switch (Interpreter.AdaptivePredict(TokenStream, 14, Context))
				{
					case 1:
						EnterOuterAlt(_localctx, 1);
						{
							State = 217; floatLiteral();
						}
						break;
					case 2:
						EnterOuterAlt(_localctx, 2);
						{
							State = 218; position();
						}
						break;
					case 3:
						EnterOuterAlt(_localctx, 3);
						{
							State = 219; path();
						}
						break;
					case 4:
						EnterOuterAlt(_localctx, 4);
						{
							State = 220; angle();
						}
						break;
					case 5:
						EnterOuterAlt(_localctx, 5);
						{
							State = 221; color();
						}
						break;
					case 6:
						EnterOuterAlt(_localctx, 6);
						{
							State = 222; Match(POV_LITERAL);
						}
						break;
					case 7:
						EnterOuterAlt(_localctx, 7);
						{
							State = 223; Match(BOOL_LITERAL);
						}
						break;
					case 8:
						EnterOuterAlt(_localctx, 8);
						{
							State = 224; Match(BOOL_YES_NO);
						}
						break;
					case 9:
						EnterOuterAlt(_localctx, 9);
						{
							State = 225; Match(ON);
						}
						break;
					case 10:
						EnterOuterAlt(_localctx, 10);
						{
							State = 226; Match(OFF);
						}
						break;
					case 11:
						EnterOuterAlt(_localctx, 11);
						{
							State = 227; Match(COLOR_LITERAL);
						}
						break;
					case 12:
						EnterOuterAlt(_localctx, 12);
						{
							State = 228; Match(TIME_LITERAL);
						}
						break;
					case 13:
						EnterOuterAlt(_localctx, 13);
						{
							State = 229; Match(STRING_LITERAL);
						}
						break;
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class ModifierContext : ParserRuleContext
		{
			public PrepositionContext preposition()
			{
				return GetRuleContext<PrepositionContext>(0);
			}
			public ModifierContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_modifier; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterModifier(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitModifier(this);
			}
		}

		[RuleVersion(0)]
		public ModifierContext modifier()
		{
			ModifierContext _localctx = new ModifierContext(Context, State);
			EnterRule(_localctx, 42, RULE_modifier);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 232; preposition();
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class PrepositionContext : ParserRuleContext
		{
			public ITerminalNode A() { return GetToken(ECARulesParser.A, 0); }
			public ITerminalNode AS() { return GetToken(ECARulesParser.AS, 0); }
			public ITerminalNode AT() { return GetToken(ECARulesParser.AT, 0); }
			public ITerminalNode AROUND() { return GetToken(ECARulesParser.AROUND, 0); }
			public ITerminalNode BY() { return GetToken(ECARulesParser.BY, 0); }
			public ITerminalNode FOR() { return GetToken(ECARulesParser.FOR, 0); }
			public ITerminalNode FROM() { return GetToken(ECARulesParser.FROM, 0); }
			public ITerminalNode IN() { return GetToken(ECARulesParser.IN, 0); }
			public ITerminalNode ON() { return GetToken(ECARulesParser.ON, 0); }
			public ITerminalNode OF() { return GetToken(ECARulesParser.OF, 0); }
			public ITerminalNode OFF() { return GetToken(ECARulesParser.OFF, 0); }
			public ITerminalNode TO() { return GetToken(ECARulesParser.TO, 0); }
			public ITerminalNode WITH() { return GetToken(ECARulesParser.WITH, 0); }
			public PrepositionContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_preposition; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterPreposition(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitPreposition(this);
			}
		}

		[RuleVersion(0)]
		public PrepositionContext preposition()
		{
			PrepositionContext _localctx = new PrepositionContext(Context, State);
			EnterRule(_localctx, 44, RULE_preposition);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 234;
					_la = TokenStream.LA(1);
					if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A) | (1L << AS) | (1L << AT) | (1L << AROUND) | (1L << BY) | (1L << FOR) | (1L << FROM) | (1L << IN) | (1L << ON) | (1L << OF) | (1L << OFF) | (1L << TO) | (1L << WITH))) != 0)))
					{
						ErrorHandler.RecoverInline(this);
					}
					else
					{
						ErrorHandler.ReportMatch(this);
						Consume();
					}
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class PropertyContext : ParserRuleContext
		{
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public ITerminalNode COLOR() { return GetToken(ECARulesParser.COLOR, 0); }
			public ITerminalNode POSITION() { return GetToken(ECARulesParser.POSITION, 0); }
			public ITerminalNode PATH() { return GetToken(ECARulesParser.PATH, 0); }
			public PropertyContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_property; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterProperty(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitProperty(this);
			}
		}

		[RuleVersion(0)]
		public PropertyContext property()
		{
			PropertyContext _localctx = new PropertyContext(Context, State);
			EnterRule(_localctx, 46, RULE_property);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 236;
					_la = TokenStream.LA(1);
					if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << COLOR) | (1L << POSITION) | (1L << PATH) | (1L << IDENTIFIER))) != 0)))
					{
						ErrorHandler.RecoverInline(this);
					}
					else
					{
						ErrorHandler.ReportMatch(this);
						Consume();
					}
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class ConditionContext : ParserRuleContext
		{
			public BaseConditionContext baseCondition()
			{
				return GetRuleContext<BaseConditionContext>(0);
			}
			public ITerminalNode NOT() { return GetToken(ECARulesParser.NOT, 0); }
			public ConditionContext[] condition()
			{
				return GetRuleContexts<ConditionContext>();
			}
			public ConditionContext condition(int i)
			{
				return GetRuleContext<ConditionContext>(i);
			}
			public ITerminalNode LPAREN() { return GetToken(ECARulesParser.LPAREN, 0); }
			public ITerminalNode RPAREN() { return GetToken(ECARulesParser.RPAREN, 0); }
			public ITerminalNode[] AND() { return GetTokens(ECARulesParser.AND); }
			public ITerminalNode AND(int i)
			{
				return GetToken(ECARulesParser.AND, i);
			}
			public ITerminalNode[] OR() { return GetTokens(ECARulesParser.OR); }
			public ITerminalNode OR(int i)
			{
				return GetToken(ECARulesParser.OR, i);
			}
			public ConditionContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_condition; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterCondition(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitCondition(this);
			}
		}

		[RuleVersion(0)]
		public ConditionContext condition()
		{
			return condition(0);
		}

		private ConditionContext condition(int _p)
		{
			ParserRuleContext _parentctx = Context;
			int _parentState = State;
			ConditionContext _localctx = new ConditionContext(Context, _parentState);
			ConditionContext _prevctx = _localctx;
			int _startState = 48;
			EnterRecursionRule(_localctx, 48, RULE_condition, _p);
			try
			{
				int _alt;
				EnterOuterAlt(_localctx, 1);
				{
					State = 246;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1))
					{
						case THE:
							{
								State = 239; baseCondition();
							}
							break;
						case NOT:
							{
								State = 240; Match(NOT);
								State = 241; condition(4);
							}
							break;
						case LPAREN:
							{
								State = 242; Match(LPAREN);
								State = 243; condition(0);
								State = 244; Match(RPAREN);
							}
							break;
						default:
							throw new NoViableAltException(this);
					}
					Context.Stop = TokenStream.LT(-1);
					State = 264;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream, 19, Context);
					while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
					{
						if (_alt == 1)
						{
							if (ParseListeners != null)
								TriggerExitRuleEvent();
							_prevctx = _localctx;
							{
								State = 262;
								ErrorHandler.Sync(this);
								switch (Interpreter.AdaptivePredict(TokenStream, 18, Context))
								{
									case 1:
										{
											_localctx = new ConditionContext(_parentctx, _parentState);
											PushNewRecursionContext(_localctx, _startState, RULE_condition);
											State = 248;
											if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
											State = 251;
											ErrorHandler.Sync(this);
											_alt = 1;
											do
											{
												switch (_alt)
												{
													case 1:
														{
															{
																State = 249; Match(AND);
																State = 250; condition(0);
															}
														}
														break;
													default:
														throw new NoViableAltException(this);
												}
												State = 253;
												ErrorHandler.Sync(this);
												_alt = Interpreter.AdaptivePredict(TokenStream, 16, Context);
											} while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER);
										}
										break;
									case 2:
										{
											_localctx = new ConditionContext(_parentctx, _parentState);
											PushNewRecursionContext(_localctx, _startState, RULE_condition);
											State = 255;
											if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
											State = 258;
											ErrorHandler.Sync(this);
											_alt = 1;
											do
											{
												switch (_alt)
												{
													case 1:
														{
															{
																State = 256; Match(OR);
																State = 257; condition(0);
															}
														}
														break;
													default:
														throw new NoViableAltException(this);
												}
												State = 260;
												ErrorHandler.Sync(this);
												_alt = Interpreter.AdaptivePredict(TokenStream, 17, Context);
											} while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER);
										}
										break;
								}
							}
						}
						State = 266;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream, 19, Context);
					}
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				UnrollRecursionContexts(_parentctx);
			}
			return _localctx;
		}

		public partial class BaseConditionContext : ParserRuleContext
		{
			public ITerminalNode THE() { return GetToken(ECARulesParser.THE, 0); }
			public TypeContext type()
			{
				return GetRuleContext<TypeContext>(0);
			}
			public ITerminalNode IDENTIFIER() { return GetToken(ECARulesParser.IDENTIFIER, 0); }
			public ValueContext value()
			{
				return GetRuleContext<ValueContext>(0);
			}
			public ObjectContext @object()
			{
				return GetRuleContext<ObjectContext>(0);
			}
			public ITerminalNode NOT() { return GetToken(ECARulesParser.NOT, 0); }
			public PropertyContext property()
			{
				return GetRuleContext<PropertyContext>(0);
			}
			public OperatorContext @operator()
			{
				return GetRuleContext<OperatorContext>(0);
			}
			public BaseConditionContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_baseCondition; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterBaseCondition(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitBaseCondition(this);
			}
		}

		[RuleVersion(0)]
		public BaseConditionContext baseCondition()
		{
			BaseConditionContext _localctx = new BaseConditionContext(Context, State);
			EnterRule(_localctx, 50, RULE_baseCondition);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 267; Match(THE);
					State = 268; type();
					State = 269; Match(IDENTIFIER);
					State = 271;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la == NOT)
					{
						{
							State = 270; Match(NOT);
						}
					}

					State = 274;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << COLOR) | (1L << POSITION) | (1L << PATH) | (1L << IDENTIFIER))) != 0))
					{
						{
							State = 273; property();
						}
					}

					State = 277;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << GT) | (1L << LT) | (1L << EQUAL) | (1L << LE) | (1L << GE) | (1L << NOTEQUAL) | (1L << AND) | (1L << OR) | (1L << ADD) | (1L << SUB) | (1L << MUL) | (1L << DIV) | (1L << MOD) | (1L << IS))) != 0))
					{
						{
							State = 276; @operator();
						}
					}

					State = 281;
					ErrorHandler.Sync(this);
					switch (Interpreter.AdaptivePredict(TokenStream, 23, Context))
					{
						case 1:
							{
								State = 279; value();
							}
							break;
						case 2:
							{
								State = 280; @object();
							}
							break;
					}
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public partial class OperatorContext : ParserRuleContext
		{
			public ITerminalNode GT() { return GetToken(ECARulesParser.GT, 0); }
			public ITerminalNode LT() { return GetToken(ECARulesParser.LT, 0); }
			public ITerminalNode EQUAL() { return GetToken(ECARulesParser.EQUAL, 0); }
			public ITerminalNode LE() { return GetToken(ECARulesParser.LE, 0); }
			public ITerminalNode GE() { return GetToken(ECARulesParser.GE, 0); }
			public ITerminalNode NOTEQUAL() { return GetToken(ECARulesParser.NOTEQUAL, 0); }
			public ITerminalNode AND() { return GetToken(ECARulesParser.AND, 0); }
			public ITerminalNode OR() { return GetToken(ECARulesParser.OR, 0); }
			public ITerminalNode ADD() { return GetToken(ECARulesParser.ADD, 0); }
			public ITerminalNode SUB() { return GetToken(ECARulesParser.SUB, 0); }
			public ITerminalNode MUL() { return GetToken(ECARulesParser.MUL, 0); }
			public ITerminalNode DIV() { return GetToken(ECARulesParser.DIV, 0); }
			public ITerminalNode MOD() { return GetToken(ECARulesParser.MOD, 0); }
			public ITerminalNode IS() { return GetToken(ECARulesParser.IS, 0); }
			public OperatorContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_operator; } }
			public override void EnterRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.EnterOperator(this);
			}
			public override void ExitRule(IParseTreeListener listener)
			{
				IECARulesParserListener typedListener = listener as IECARulesParserListener;
				if (typedListener != null) typedListener.ExitOperator(this);
			}
		}

		[RuleVersion(0)]
		public OperatorContext @operator()
		{
			OperatorContext _localctx = new OperatorContext(Context, State);
			EnterRule(_localctx, 52, RULE_operator);
			int _la;
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 283;
					_la = TokenStream.LA(1);
					if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << GT) | (1L << LT) | (1L << EQUAL) | (1L << LE) | (1L << GE) | (1L << NOTEQUAL) | (1L << AND) | (1L << OR) | (1L << ADD) | (1L << SUB) | (1L << MUL) | (1L << DIV) | (1L << MOD) | (1L << IS))) != 0)))
					{
						ErrorHandler.RecoverInline(this);
					}
					else
					{
						ErrorHandler.ReportMatch(this);
						Consume();
					}
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex)
		{
			switch (ruleIndex)
			{
				case 24: return condition_sempred((ConditionContext)_localctx, predIndex);
			}
			return true;
		}
		private bool condition_sempred(ConditionContext _localctx, int predIndex)
		{
			switch (predIndex)
			{
				case 0: return Precpred(Context, 3);
				case 1: return Precpred(Context, 2);
			}
			return true;
		}

		private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786',
		'\x5964', '\x3', '\x41', '\x120', '\x4', '\x2', '\t', '\x2', '\x4', '\x3',
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4',
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b',
		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v',
		'\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t',
		'\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4',
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t',
		'\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4',
		'\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t',
		'\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4',
		'\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x3', '\x2', '\x6',
		'\x2', ':', '\n', '\x2', '\r', '\x2', '\xE', '\x2', ';', '\x3', '\x2',
		'\a', '\x2', '?', '\n', '\x2', '\f', '\x2', '\xE', '\x2', '\x42', '\v',
		'\x2', '\x3', '\x2', '\x6', '\x2', '\x45', '\n', '\x2', '\r', '\x2', '\xE',
		'\x2', '\x46', '\x3', '\x2', '\a', '\x2', 'J', '\n', '\x2', '\f', '\x2',
		'\xE', '\x2', 'M', '\v', '\x2', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3',
		'\x3', '\x3', '\x5', '\x3', 'S', '\n', '\x3', '\x3', '\x4', '\x3', '\x4',
		'\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x5', '\x3', '\x5',
		'\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5',
		'\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6',
		'\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\a', '\x3', '\a', '\x3',
		'\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a',
		'\x5', '\a', 'q', '\n', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3',
		'\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b',
		'\x3', '\b', '\x3', '\t', '\x3', '\t', '\x3', '\n', '\x3', '\n', '\x3',
		'\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\f', '\x3', '\f',
		'\x3', '\f', '\x3', '\f', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3',
		'\r', '\x3', '\r', '\x5', '\r', '\x8E', '\n', '\r', '\x3', '\xE', '\x3',
		'\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xF', '\x3', '\xF', '\x3',
		'\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3',
		'\xF', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3',
		'\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x11', '\x3',
		'\x11', '\x3', '\x11', '\x3', '\x11', '\x5', '\x11', '\xA8', '\n', '\x11',
		'\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\a', '\x11',
		'\xAE', '\n', '\x11', '\f', '\x11', '\xE', '\x11', '\xB1', '\v', '\x11',
		'\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12',
		'\x3', '\x12', '\x5', '\x12', '\xB9', '\n', '\x12', '\x3', '\x12', '\x3',
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x5', '\x12', '\xC0',
		'\n', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12',
		'\x3', '\x12', '\x5', '\x12', '\xC7', '\n', '\x12', '\x3', '\x12', '\x3',
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x5', '\x12', '\xCD', '\n', '\x12',
		'\x3', '\x12', '\x5', '\x12', '\xD0', '\n', '\x12', '\x3', '\x13', '\x3',
		'\x13', '\x3', '\x13', '\x3', '\x13', '\x3', '\x14', '\x3', '\x14', '\x3',
		'\x15', '\x3', '\x15', '\x3', '\x15', '\x3', '\x15', '\x3', '\x16', '\x3',
		'\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3',
		'\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', '\x3',
		'\x16', '\x3', '\x16', '\x5', '\x16', '\xE9', '\n', '\x16', '\x3', '\x17',
		'\x3', '\x17', '\x3', '\x18', '\x3', '\x18', '\x3', '\x19', '\x3', '\x19',
		'\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A',
		'\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x5', '\x1A', '\xF9', '\n',
		'\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x6', '\x1A', '\xFE',
		'\n', '\x1A', '\r', '\x1A', '\xE', '\x1A', '\xFF', '\x3', '\x1A', '\x3',
		'\x1A', '\x3', '\x1A', '\x6', '\x1A', '\x105', '\n', '\x1A', '\r', '\x1A',
		'\xE', '\x1A', '\x106', '\a', '\x1A', '\x109', '\n', '\x1A', '\f', '\x1A',
		'\xE', '\x1A', '\x10C', '\v', '\x1A', '\x3', '\x1B', '\x3', '\x1B', '\x3',
		'\x1B', '\x3', '\x1B', '\x5', '\x1B', '\x112', '\n', '\x1B', '\x3', '\x1B',
		'\x5', '\x1B', '\x115', '\n', '\x1B', '\x3', '\x1B', '\x5', '\x1B', '\x118',
		'\n', '\x1B', '\x3', '\x1B', '\x3', '\x1B', '\x5', '\x1B', '\x11C', '\n',
		'\x1B', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x2', '\x3', '\x32',
		'\x1D', '\x2', '\x4', '\x6', '\b', '\n', '\f', '\xE', '\x10', '\x12',
		'\x14', '\x16', '\x18', '\x1A', '\x1C', '\x1E', ' ', '\"', '$', '&', '(',
		'*', ',', '.', '\x30', '\x32', '\x34', '\x36', '\x2', '\a', '\x4', '\x2',
		'<', '<', '?', '?', '\x3', '\x2', '\b', '\n', '\x3', '\x2', '*', '\x36',
		'\x4', '\x2', '\'', ')', '=', '=', '\x4', '\x2', '\xF', '\x10', '\x12',
		'\x1D', '\x2', '\x12D', '\x2', '\x39', '\x3', '\x2', '\x2', '\x2', '\x4',
		'R', '\x3', '\x2', '\x2', '\x2', '\x6', 'T', '\x3', '\x2', '\x2', '\x2',
		'\b', 'Y', '\x3', '\x2', '\x2', '\x2', '\n', '`', '\x3', '\x2', '\x2',
		'\x2', '\f', 'h', '\x3', '\x2', '\x2', '\x2', '\xE', 'u', '\x3', '\x2',
		'\x2', '\x2', '\x10', '|', '\x3', '\x2', '\x2', '\x2', '\x12', '~', '\x3',
		'\x2', '\x2', '\x2', '\x14', '\x80', '\x3', '\x2', '\x2', '\x2', '\x16',
		'\x84', '\x3', '\x2', '\x2', '\x2', '\x18', '\x88', '\x3', '\x2', '\x2',
		'\x2', '\x1A', '\x8F', '\x3', '\x2', '\x2', '\x2', '\x1C', '\x93', '\x3',
		'\x2', '\x2', '\x2', '\x1E', '\x9B', '\x3', '\x2', '\x2', '\x2', ' ',
		'\xA3', '\x3', '\x2', '\x2', '\x2', '\"', '\xCF', '\x3', '\x2', '\x2',
		'\x2', '$', '\xD1', '\x3', '\x2', '\x2', '\x2', '&', '\xD5', '\x3', '\x2',
		'\x2', '\x2', '(', '\xD7', '\x3', '\x2', '\x2', '\x2', '*', '\xE8', '\x3',
		'\x2', '\x2', '\x2', ',', '\xEA', '\x3', '\x2', '\x2', '\x2', '.', '\xEC',
		'\x3', '\x2', '\x2', '\x2', '\x30', '\xEE', '\x3', '\x2', '\x2', '\x2',
		'\x32', '\xF8', '\x3', '\x2', '\x2', '\x2', '\x34', '\x10D', '\x3', '\x2',
		'\x2', '\x2', '\x36', '\x11D', '\x3', '\x2', '\x2', '\x2', '\x38', ':',
		'\x5', '\x4', '\x3', '\x2', '\x39', '\x38', '\x3', '\x2', '\x2', '\x2',
		':', ';', '\x3', '\x2', '\x2', '\x2', ';', '\x39', '\x3', '\x2', '\x2',
		'\x2', ';', '<', '\x3', '\x2', '\x2', '\x2', '<', '@', '\x3', '\x2', '\x2',
		'\x2', '=', '?', '\x5', '\x1C', '\xF', '\x2', '>', '=', '\x3', '\x2',
		'\x2', '\x2', '?', '\x42', '\x3', '\x2', '\x2', '\x2', '@', '>', '\x3',
		'\x2', '\x2', '\x2', '@', '\x41', '\x3', '\x2', '\x2', '\x2', '\x41',
		'\x44', '\x3', '\x2', '\x2', '\x2', '\x42', '@', '\x3', '\x2', '\x2',
		'\x2', '\x43', '\x45', '\x5', ' ', '\x11', '\x2', '\x44', '\x43', '\x3',
		'\x2', '\x2', '\x2', '\x45', '\x46', '\x3', '\x2', '\x2', '\x2', '\x46',
		'\x44', '\x3', '\x2', '\x2', '\x2', '\x46', 'G', '\x3', '\x2', '\x2',
		'\x2', 'G', 'K', '\x3', '\x2', '\x2', '\x2', 'H', 'J', '\x5', '\x1E',
		'\x10', '\x2', 'I', 'H', '\x3', '\x2', '\x2', '\x2', 'J', 'M', '\x3',
		'\x2', '\x2', '\x2', 'K', 'I', '\x3', '\x2', '\x2', '\x2', 'K', 'L', '\x3',
		'\x2', '\x2', '\x2', 'L', '\x3', '\x3', '\x2', '\x2', '\x2', 'M', 'K',
		'\x3', '\x2', '\x2', '\x2', 'N', 'S', '\x5', '\x6', '\x4', '\x2', 'O',
		'S', '\x5', '\b', '\x5', '\x2', 'P', 'S', '\x5', '\f', '\a', '\x2', 'Q',
		'S', '\x5', '\xE', '\b', '\x2', 'R', 'N', '\x3', '\x2', '\x2', '\x2',
		'R', 'O', '\x3', '\x2', '\x2', '\x2', 'R', 'P', '\x3', '\x2', '\x2', '\x2',
		'R', 'Q', '\x3', '\x2', '\x2', '\x2', 'S', '\x5', '\x3', '\x2', '\x2',
		'\x2', 'T', 'U', '\a', '\f', '\x2', '\x2', 'U', 'V', '\x5', '\x12', '\n',
		'\x2', 'V', 'W', '\a', '=', '\x2', '\x2', 'W', 'X', '\a', '$', '\x2',
		'\x2', 'X', '\a', '\x3', '\x2', '\x2', '\x2', 'Y', 'Z', '\a', '\f', '\x2',
		'\x2', 'Z', '[', '\a', '(', '\x2', '\x2', '[', '\\', '\a', '=', '\x2',
		'\x2', '\\', ']', '\a', '\x12', '\x2', '\x2', ']', '^', '\x5', '\n', '\x6',
		'\x2', '^', '_', '\a', '$', '\x2', '\x2', '_', '\t', '\x3', '\x2', '\x2',
		'\x2', '`', '\x61', '\a', '\x1E', '\x2', '\x2', '\x61', '\x62', '\x5',
		'\x10', '\t', '\x2', '\x62', '\x63', '\a', '%', '\x2', '\x2', '\x63',
		'\x64', '\x5', '\x10', '\t', '\x2', '\x64', '\x65', '\a', '%', '\x2',
		'\x2', '\x65', '\x66', '\x5', '\x10', '\t', '\x2', '\x66', 'g', '\a',
		'\x1F', '\x2', '\x2', 'g', '\v', '\x3', '\x2', '\x2', '\x2', 'h', 'i',
		'\a', '\f', '\x2', '\x2', 'i', 'j', '\a', ')', '\x2', '\x2', 'j', 'k',
		'\a', '=', '\x2', '\x2', 'k', 'l', '\a', '\x12', '\x2', '\x2', 'l', 'm',
		'\a', ' ', '\x2', '\x2', 'm', 'p', '\x5', '\n', '\x6', '\x2', 'n', 'o',
		'\a', '%', '\x2', '\x2', 'o', 'q', '\x5', '\n', '\x6', '\x2', 'p', 'n',
		'\x3', '\x2', '\x2', '\x2', 'p', 'q', '\x3', '\x2', '\x2', '\x2', 'q',
		'r', '\x3', '\x2', '\x2', '\x2', 'r', 's', '\a', '!', '\x2', '\x2', 's',
		't', '\a', '$', '\x2', '\x2', 't', '\r', '\x3', '\x2', '\x2', '\x2', 'u',
		'v', '\a', '\f', '\x2', '\x2', 'v', 'w', '\a', '\'', '\x2', '\x2', 'w',
		'x', '\a', '=', '\x2', '\x2', 'x', 'y', '\a', '\x12', '\x2', '\x2', 'y',
		'z', '\a', ';', '\x2', '\x2', 'z', '{', '\a', '$', '\x2', '\x2', '{',
		'\xF', '\x3', '\x2', '\x2', '\x2', '|', '}', '\t', '\x2', '\x2', '\x2',
		'}', '\x11', '\x3', '\x2', '\x2', '\x2', '~', '\x7F', '\a', '=', '\x2',
		'\x2', '\x7F', '\x13', '\x3', '\x2', '\x2', '\x2', '\x80', '\x81', '\a',
		'\a', '\x2', '\x2', '\x81', '\x82', '\a', '(', '\x2', '\x2', '\x82', '\x83',
		'\a', '=', '\x2', '\x2', '\x83', '\x15', '\x3', '\x2', '\x2', '\x2', '\x84',
		'\x85', '\a', '\a', '\x2', '\x2', '\x85', '\x86', '\a', ')', '\x2', '\x2',
		'\x86', '\x87', '\a', '=', '\x2', '\x2', '\x87', '\x17', '\x3', '\x2',
		'\x2', '\x2', '\x88', '\x89', '\x5', '\x10', '\t', '\x2', '\x89', '\x8D',
		'\a', '\x37', '\x2', '\x2', '\x8A', '\x8B', '\a', '-', '\x2', '\x2', '\x8B',
		'\x8C', '\t', '\x3', '\x2', '\x2', '\x8C', '\x8E', '\a', '\v', '\x2',
		'\x2', '\x8D', '\x8A', '\x3', '\x2', '\x2', '\x2', '\x8D', '\x8E', '\x3',
		'\x2', '\x2', '\x2', '\x8E', '\x19', '\x3', '\x2', '\x2', '\x2', '\x8F',
		'\x90', '\a', '\a', '\x2', '\x2', '\x90', '\x91', '\a', '\'', '\x2', '\x2',
		'\x91', '\x92', '\a', '=', '\x2', '\x2', '\x92', '\x1B', '\x3', '\x2',
		'\x2', '\x2', '\x93', '\x94', '\a', '\a', '\x2', '\x2', '\x94', '\x95',
		'\x5', '\x12', '\n', '\x2', '\x95', '\x96', '\a', '=', '\x2', '\x2', '\x96',
		'\x97', '\a', '\xE', '\x2', '\x2', '\x97', '\x98', '\a', '*', '\x2', '\x2',
		'\x98', '\x99', '\x5', '\x12', '\n', '\x2', '\x99', '\x9A', '\a', '$',
		'\x2', '\x2', '\x9A', '\x1D', '\x3', '\x2', '\x2', '\x2', '\x9B', '\x9C',
		'\a', '\f', '\x2', '\x2', '\x9C', '\x9D', '\x5', '\x12', '\n', '\x2',
		'\x9D', '\x9E', '\a', '+', '\x2', '\x2', '\x9E', '\x9F', '\a', '>', '\x2',
		'\x2', '\x9F', '\xA0', '\a', '/', '\x2', '\x2', '\xA0', '\xA1', '\a',
		'=', '\x2', '\x2', '\xA1', '\xA2', '\a', '$', '\x2', '\x2', '\xA2', '\x1F',
		'\x3', '\x2', '\x2', '\x2', '\xA3', '\xA4', '\a', '\x4', '\x2', '\x2',
		'\xA4', '\xA7', '\x5', '\"', '\x12', '\x2', '\xA5', '\xA6', '\a', '\x6',
		'\x2', '\x2', '\xA6', '\xA8', '\x5', '\x32', '\x1A', '\x2', '\xA7', '\xA5',
		'\x3', '\x2', '\x2', '\x2', '\xA7', '\xA8', '\x3', '\x2', '\x2', '\x2',
		'\xA8', '\xA9', '\x3', '\x2', '\x2', '\x2', '\xA9', '\xAF', '\a', '\x5',
		'\x2', '\x2', '\xAA', '\xAB', '\x5', '\"', '\x12', '\x2', '\xAB', '\xAC',
		'\a', '$', '\x2', '\x2', '\xAC', '\xAE', '\x3', '\x2', '\x2', '\x2', '\xAD',
		'\xAA', '\x3', '\x2', '\x2', '\x2', '\xAE', '\xB1', '\x3', '\x2', '\x2',
		'\x2', '\xAF', '\xAD', '\x3', '\x2', '\x2', '\x2', '\xAF', '\xB0', '\x3',
		'\x2', '\x2', '\x2', '\xB0', '!', '\x3', '\x2', '\x2', '\x2', '\xB1',
		'\xAF', '\x3', '\x2', '\x2', '\x2', '\xB2', '\xB3', '\x5', '$', '\x13',
		'\x2', '\xB3', '\xB4', '\x5', '&', '\x14', '\x2', '\xB4', '\xD0', '\x3',
		'\x2', '\x2', '\x2', '\xB5', '\xB6', '\x5', '$', '\x13', '\x2', '\xB6',
		'\xB8', '\x5', '&', '\x14', '\x2', '\xB7', '\xB9', '\x5', '.', '\x18',
		'\x2', '\xB8', '\xB7', '\x3', '\x2', '\x2', '\x2', '\xB8', '\xB9', '\x3',
		'\x2', '\x2', '\x2', '\xB9', '\xBA', '\x3', '\x2', '\x2', '\x2', '\xBA',
		'\xBB', '\x5', '(', '\x15', '\x2', '\xBB', '\xD0', '\x3', '\x2', '\x2',
		'\x2', '\xBC', '\xBD', '\x5', '$', '\x13', '\x2', '\xBD', '\xBF', '\x5',
		'&', '\x14', '\x2', '\xBE', '\xC0', '\x5', '.', '\x18', '\x2', '\xBF',
		'\xBE', '\x3', '\x2', '\x2', '\x2', '\xBF', '\xC0', '\x3', '\x2', '\x2',
		'\x2', '\xC0', '\xC1', '\x3', '\x2', '\x2', '\x2', '\xC1', '\xC2', '\x5',
		'*', '\x16', '\x2', '\xC2', '\xD0', '\x3', '\x2', '\x2', '\x2', '\xC3',
		'\xC4', '\x5', '$', '\x13', '\x2', '\xC4', '\xC6', '\x5', '&', '\x14',
		'\x2', '\xC5', '\xC7', '\x5', '.', '\x18', '\x2', '\xC6', '\xC5', '\x3',
		'\x2', '\x2', '\x2', '\xC6', '\xC7', '\x3', '\x2', '\x2', '\x2', '\xC7',
		'\xC8', '\x3', '\x2', '\x2', '\x2', '\xC8', '\xC9', '\x5', '\x30', '\x19',
		'\x2', '\xC9', '\xCA', '\x5', ',', '\x17', '\x2', '\xCA', '\xCC', '\x5',
		'*', '\x16', '\x2', '\xCB', '\xCD', '\a', '\x41', '\x2', '\x2', '\xCC',
		'\xCB', '\x3', '\x2', '\x2', '\x2', '\xCC', '\xCD', '\x3', '\x2', '\x2',
		'\x2', '\xCD', '\xD0', '\x3', '\x2', '\x2', '\x2', '\xCE', '\xD0', '\x3',
		'\x2', '\x2', '\x2', '\xCF', '\xB2', '\x3', '\x2', '\x2', '\x2', '\xCF',
		'\xB5', '\x3', '\x2', '\x2', '\x2', '\xCF', '\xBC', '\x3', '\x2', '\x2',
		'\x2', '\xCF', '\xC3', '\x3', '\x2', '\x2', '\x2', '\xCF', '\xCE', '\x3',
		'\x2', '\x2', '\x2', '\xD0', '#', '\x3', '\x2', '\x2', '\x2', '\xD1',
		'\xD2', '\a', '\a', '\x2', '\x2', '\xD2', '\xD3', '\x5', '\x12', '\n',
		'\x2', '\xD3', '\xD4', '\a', '=', '\x2', '\x2', '\xD4', '%', '\x3', '\x2',
		'\x2', '\x2', '\xD5', '\xD6', '\a', '=', '\x2', '\x2', '\xD6', '\'', '\x3',
		'\x2', '\x2', '\x2', '\xD7', '\xD8', '\a', '\a', '\x2', '\x2', '\xD8',
		'\xD9', '\x5', '\x12', '\n', '\x2', '\xD9', '\xDA', '\a', '=', '\x2',
		'\x2', '\xDA', ')', '\x3', '\x2', '\x2', '\x2', '\xDB', '\xE9', '\x5',
		'\x10', '\t', '\x2', '\xDC', '\xE9', '\x5', '\x14', '\v', '\x2', '\xDD',
		'\xE9', '\x5', '\x16', '\f', '\x2', '\xDE', '\xE9', '\x5', '\x18', '\r',
		'\x2', '\xDF', '\xE9', '\x5', '\x1A', '\xE', '\x2', '\xE0', '\xE9', '\a',
		'\x38', '\x2', '\x2', '\xE1', '\xE9', '\a', '\x39', '\x2', '\x2', '\xE2',
		'\xE9', '\a', ':', '\x2', '\x2', '\xE3', '\xE9', '\a', '\x32', '\x2',
		'\x2', '\xE4', '\xE9', '\a', '\x34', '\x2', '\x2', '\xE5', '\xE9', '\a',
		';', '\x2', '\x2', '\xE6', '\xE9', '\a', '@', '\x2', '\x2', '\xE7', '\xE9',
		'\a', '>', '\x2', '\x2', '\xE8', '\xDB', '\x3', '\x2', '\x2', '\x2', '\xE8',
		'\xDC', '\x3', '\x2', '\x2', '\x2', '\xE8', '\xDD', '\x3', '\x2', '\x2',
		'\x2', '\xE8', '\xDE', '\x3', '\x2', '\x2', '\x2', '\xE8', '\xDF', '\x3',
		'\x2', '\x2', '\x2', '\xE8', '\xE0', '\x3', '\x2', '\x2', '\x2', '\xE8',
		'\xE1', '\x3', '\x2', '\x2', '\x2', '\xE8', '\xE2', '\x3', '\x2', '\x2',
		'\x2', '\xE8', '\xE3', '\x3', '\x2', '\x2', '\x2', '\xE8', '\xE4', '\x3',
		'\x2', '\x2', '\x2', '\xE8', '\xE5', '\x3', '\x2', '\x2', '\x2', '\xE8',
		'\xE6', '\x3', '\x2', '\x2', '\x2', '\xE8', '\xE7', '\x3', '\x2', '\x2',
		'\x2', '\xE9', '+', '\x3', '\x2', '\x2', '\x2', '\xEA', '\xEB', '\x5',
		'.', '\x18', '\x2', '\xEB', '-', '\x3', '\x2', '\x2', '\x2', '\xEC', '\xED',
		'\t', '\x4', '\x2', '\x2', '\xED', '/', '\x3', '\x2', '\x2', '\x2', '\xEE',
		'\xEF', '\t', '\x5', '\x2', '\x2', '\xEF', '\x31', '\x3', '\x2', '\x2',
		'\x2', '\xF0', '\xF1', '\b', '\x1A', '\x1', '\x2', '\xF1', '\xF9', '\x5',
		'\x34', '\x1B', '\x2', '\xF2', '\xF3', '\a', '\x11', '\x2', '\x2', '\xF3',
		'\xF9', '\x5', '\x32', '\x1A', '\x6', '\xF4', '\xF5', '\a', '\x1E', '\x2',
		'\x2', '\xF5', '\xF6', '\x5', '\x32', '\x1A', '\x2', '\xF6', '\xF7', '\a',
		'\x1F', '\x2', '\x2', '\xF7', '\xF9', '\x3', '\x2', '\x2', '\x2', '\xF8',
		'\xF0', '\x3', '\x2', '\x2', '\x2', '\xF8', '\xF2', '\x3', '\x2', '\x2',
		'\x2', '\xF8', '\xF4', '\x3', '\x2', '\x2', '\x2', '\xF9', '\x10A', '\x3',
		'\x2', '\x2', '\x2', '\xFA', '\xFD', '\f', '\x5', '\x2', '\x2', '\xFB',
		'\xFC', '\a', '\x16', '\x2', '\x2', '\xFC', '\xFE', '\x5', '\x32', '\x1A',
		'\x2', '\xFD', '\xFB', '\x3', '\x2', '\x2', '\x2', '\xFE', '\xFF', '\x3',
		'\x2', '\x2', '\x2', '\xFF', '\xFD', '\x3', '\x2', '\x2', '\x2', '\xFF',
		'\x100', '\x3', '\x2', '\x2', '\x2', '\x100', '\x109', '\x3', '\x2', '\x2',
		'\x2', '\x101', '\x104', '\f', '\x4', '\x2', '\x2', '\x102', '\x103',
		'\a', '\x17', '\x2', '\x2', '\x103', '\x105', '\x5', '\x32', '\x1A', '\x2',
		'\x104', '\x102', '\x3', '\x2', '\x2', '\x2', '\x105', '\x106', '\x3',
		'\x2', '\x2', '\x2', '\x106', '\x104', '\x3', '\x2', '\x2', '\x2', '\x106',
		'\x107', '\x3', '\x2', '\x2', '\x2', '\x107', '\x109', '\x3', '\x2', '\x2',
		'\x2', '\x108', '\xFA', '\x3', '\x2', '\x2', '\x2', '\x108', '\x101',
		'\x3', '\x2', '\x2', '\x2', '\x109', '\x10C', '\x3', '\x2', '\x2', '\x2',
		'\x10A', '\x108', '\x3', '\x2', '\x2', '\x2', '\x10A', '\x10B', '\x3',
		'\x2', '\x2', '\x2', '\x10B', '\x33', '\x3', '\x2', '\x2', '\x2', '\x10C',
		'\x10A', '\x3', '\x2', '\x2', '\x2', '\x10D', '\x10E', '\a', '\a', '\x2',
		'\x2', '\x10E', '\x10F', '\x5', '\x12', '\n', '\x2', '\x10F', '\x111',
		'\a', '=', '\x2', '\x2', '\x110', '\x112', '\a', '\x11', '\x2', '\x2',
		'\x111', '\x110', '\x3', '\x2', '\x2', '\x2', '\x111', '\x112', '\x3',
		'\x2', '\x2', '\x2', '\x112', '\x114', '\x3', '\x2', '\x2', '\x2', '\x113',
		'\x115', '\x5', '\x30', '\x19', '\x2', '\x114', '\x113', '\x3', '\x2',
		'\x2', '\x2', '\x114', '\x115', '\x3', '\x2', '\x2', '\x2', '\x115', '\x117',
		'\x3', '\x2', '\x2', '\x2', '\x116', '\x118', '\x5', '\x36', '\x1C', '\x2',
		'\x117', '\x116', '\x3', '\x2', '\x2', '\x2', '\x117', '\x118', '\x3',
		'\x2', '\x2', '\x2', '\x118', '\x11B', '\x3', '\x2', '\x2', '\x2', '\x119',
		'\x11C', '\x5', '*', '\x16', '\x2', '\x11A', '\x11C', '\x5', '(', '\x15',
		'\x2', '\x11B', '\x119', '\x3', '\x2', '\x2', '\x2', '\x11B', '\x11A',
		'\x3', '\x2', '\x2', '\x2', '\x11C', '\x35', '\x3', '\x2', '\x2', '\x2',
		'\x11D', '\x11E', '\t', '\x6', '\x2', '\x2', '\x11E', '\x37', '\x3', '\x2',
		'\x2', '\x2', '\x1A', ';', '@', '\x46', 'K', 'R', 'p', '\x8D', '\xA7',
		'\xAF', '\xB8', '\xBF', '\xC6', '\xCC', '\xCF', '\xE8', '\xF8', '\xFF',
		'\x106', '\x108', '\x10A', '\x111', '\x114', '\x117', '\x11B',
	};

		public static readonly ATN _ATN =
			new ATNDeserializer().Deserialize(_serializedATN);

	}

}